"""
UI Inspector - Inspetor de Elementos para Programas Desktop Windows
Desenvolvido para automação RPA com UIA3

Uso:
    python main.py

Controles durante captura:
    CTRL + Click - Capturar elemento sob o cursor
    ESC - Cancelar captura
"""
import sys
import os
from element_inspector import ElementInspector
from utils import *

class UIInspectorApp:
    """Aplicação principal do UI Inspector"""
    
    def __init__(self):
        self.inspector = ElementInspector()
        self.running = True
    
    def show_banner(self):
        """Exibe banner da aplicação"""
        print_colored("=" * 70, Fore.CYAN)
        print_colored("                    UI INSPECTOR v1.0", Fore.YELLOW)
        print_colored("              Inspetor de Elementos Windows Desktop", Fore.WHITE)
        print_colored("                    Powered by UIA3", Fore.GREEN)
        print_colored("=" * 70, Fore.CYAN)
        print()
    
    def show_main_menu(self):
        """Exibe menu principal"""
        print_header("MENU PRINCIPAL")
        print_colored("1. Capturar Elemento", Fore.WHITE)
        print_colored("2. Listar Elementos Capturados", Fore.WHITE)
        print_colored("3. Abrir Pasta de Elementos", Fore.WHITE)
        print_colored("4. Ajuda", Fore.WHITE)
        print_colored("5. Sair", Fore.WHITE)
        print()
    
    def get_user_choice(self):
        """Obtém escolha do usuário"""
        try:
            choice = input(f"{Fore.CYAN}Escolha uma opção (1-5): {Style.RESET_ALL}").strip()
            return choice
        except KeyboardInterrupt:
            return "5"
        except:
            return ""
    
    def capture_element_workflow(self):
        """Fluxo completo de captura de elemento"""
        print_header("CAPTURA DE ELEMENTO")
        
        # Solicita nome do elemento
        element_name = input(f"{Fore.CYAN}Digite um nome para o elemento: {Style.RESET_ALL}").strip()
        
        if not element_name:
            print_error("Nome do elemento é obrigatório")
            wait_for_keypress()
            return
        
        print()
        print_warning("INSTRUÇÕES:")
        print_colored("• CTRL + Click no elemento para capturar", Fore.WHITE)
        print_colored("• ESC para cancelar", Fore.WHITE)
        print()
        
        # Inicia captura imediatamente
        result = self.inspector.start_capture_mode(element_name)
        
        if result:
            print()
            print_success("Elemento capturado com sucesso!")
            
            # Oferece visualizar detalhes
            view_details = input(f"{Fore.CYAN}Deseja visualizar os detalhes? (s/n): {Style.RESET_ALL}").strip().lower()
            
            if view_details in ['s', 'sim', 'y', 'yes']:
                self.show_element_details(result['element_data'])
        else:
            print_warning("Captura cancelada ou falhou")
        
        wait_for_keypress()
    
    def list_captured_elements(self):
        """Lista elementos capturados"""
        print_header("ELEMENTOS CAPTURADOS")
        
        base_folder = "captured_elements"
        
        if not os.path.exists(base_folder):
            print_warning("Nenhum elemento capturado ainda")
            wait_for_keypress()
            return
        
        try:
            elements = os.listdir(base_folder)
            elements = [d for d in elements if os.path.isdir(os.path.join(base_folder, d))]
            
            if not elements:
                print_warning("Nenhum elemento capturado ainda")
            else:
                print_info(f"Total de elementos capturados: {len(elements)}")
                print()
                
                # Mostra lista numerada dos elementos
                for i, element_folder in enumerate(sorted(elements), 1):
                    print_colored(f"{i:2d}. {element_folder}", Fore.CYAN)
                    
                    # Tenta carregar informações básicas para prévia
                    try:
                        file_path = os.path.join(base_folder, element_folder, "element_data.json")
                        if os.path.exists(file_path):
                            import json
                            with open(file_path, 'r', encoding='utf-8') as f:
                                data = json.load(f)
                            
                            name = data.get('name', 'N/A')
                            control_type = data.get('control_type', 'N/A')
                            captured_at = data.get('captured_at', 'N/A')
                            
                            print_colored(f"    {name} ({control_type}) - {captured_at[:19] if captured_at != 'N/A' else 'N/A'}", Fore.WHITE)
                    except Exception:
                        print_colored(f"    Erro ao ler preview", Fore.RED)
                    print()
                
                print_colored("Opções:", Fore.YELLOW)
                print_colored("• Digite o número do elemento para ver DETALHES COMPLETOS", Fore.WHITE)
                print_colored("• Digite 'todos' para ver TODOS os elementos em detalhes", Fore.WHITE)
                print_colored("• ENTER para voltar ao menu", Fore.WHITE)
                print()
                
                choice = input(f"{Fore.CYAN}Sua escolha: {Style.RESET_ALL}").strip().lower()
                
                if choice == 'todos':
                    # Mostra todos os elementos em detalhes
                    for i, element_folder in enumerate(sorted(elements), 1):
                        print()
                        print_colored("=" * 70, Fore.MAGENTA)
                        print_colored(f"ELEMENTO {i}: {element_folder}", Fore.YELLOW)
                        print_colored("=" * 70, Fore.MAGENTA)
                        self.show_saved_element_details(element_folder)
                        
                        if i < len(elements):  # Não pergunta no último elemento
                            continue_viewing = input(f"{Fore.CYAN}Continuar para próximo elemento? (s/n): {Style.RESET_ALL}").strip().lower()
                            if continue_viewing not in ['s', 'sim', 'y', 'yes', '']:
                                break
                
                elif choice.isdigit():
                    idx = int(choice) - 1
                    if 0 <= idx < len(elements):
                        print()
                        print_colored("=" * 70, Fore.MAGENTA)
                        print_colored(f"ELEMENTO SELECIONADO: {elements[idx]}", Fore.YELLOW)
                        print_colored("=" * 70, Fore.MAGENTA)
                        self.show_saved_element_details(elements[idx])
                    else:
                        print_error("Número inválido")
        
        except Exception as e:
            print_error(f"Erro ao listar elementos: {str(e)}")
        
        wait_for_keypress()
    
    def show_element_details(self, element_data):
        """Exibe detalhes completos do elemento"""
        print_header("DETALHES DO ELEMENTO")
        
        # Função auxiliar para acessar dados de forma segura
        def safe_get(data, key, default='N/A'):
            if isinstance(data, dict):
                return data.get(key, default)
            return default
        
        # Propriedades principais
        print_colored("PROPRIEDADES PRINCIPAIS:", Fore.YELLOW)
        print_colored(f"  AutomationId: {safe_get(element_data, 'automation_id')}", Fore.WHITE)
        print_colored(f"  Name: {safe_get(element_data, 'name')}", Fore.WHITE)
        print_colored(f"  ClassName: {safe_get(element_data, 'class_name')}", Fore.WHITE)
        print_colored(f"  ControlType: {safe_get(element_data, 'control_type')}", Fore.WHITE)
        print_colored(f"  LocalizedControlType: {safe_get(element_data, 'localized_control_type')}", Fore.WHITE)
        print_colored(f"  FrameworkId: {safe_get(element_data, 'framework_id')}", Fore.WHITE)
        print_colored(f"  FrameworkType: {safe_get(element_data, 'framework_type')}", Fore.WHITE)
        print_colored(f"  ProcessId: {safe_get(element_data, 'process_id')}", Fore.WHITE)
        print()
        
        # Informações da janela
        window_info = element_data.get('window_info', {}) if isinstance(element_data, dict) else {}
        if isinstance(window_info, dict) and window_info and not window_info.get('error'):
            print_colored("JANELA:", Fore.YELLOW)
            print_colored(f"  Título: {safe_get(window_info, 'title')}", Fore.WHITE)
            print_colored(f"  Classe: {safe_get(window_info, 'class_name')}", Fore.WHITE)
            
            # AutomationId com tratamento especial
            automation_id = safe_get(window_info, 'automation_id')
            if automation_id and automation_id != 'N/A':
                if automation_id.startswith('[') and automation_id.endswith(']'):
                    # É uma informação de debug - mostra em amarelo
                    print_colored(f"  AutomationId: {automation_id}", Fore.YELLOW)
                else:
                    # É um AutomationId válido - mostra em branco
                    print_colored(f"  AutomationId: {automation_id}", Fore.WHITE)
            else:
                print_colored(f"  AutomationId: {automation_id}", Fore.WHITE)
            
            print()  # Linha em branco após a seção JANELA
            
        elif isinstance(window_info, str):
            print_colored("JANELA:", Fore.YELLOW)
            print_colored(f"  Informação: {window_info}", Fore.WHITE)
            print()  # Linha em branco após a seção JANELA
        
        # Estados
        print_colored("ESTADOS:", Fore.YELLOW)
        print_colored(f"  Habilitado: {safe_get(element_data, 'is_enabled')}", Fore.WHITE)
        print_colored(f"  Visível: {safe_get(element_data, 'is_visible')}", Fore.WHITE)
        print_colored(f"  Focalizável: {safe_get(element_data, 'is_keyboard_focusable')}", Fore.WHITE)
        print()
        
        # Geometria
        rect = element_data.get('bounding_rectangle', {}) if isinstance(element_data, dict) else {}
        if isinstance(rect, dict) and rect:
            print_colored("GEOMETRIA:", Fore.YELLOW)
            print_colored(f"  Posição: ({safe_get(rect, 'left')}, {safe_get(rect, 'top')})", Fore.WHITE)
            print_colored(f"  Tamanho: {safe_get(rect, 'width')} x {safe_get(rect, 'height')}", Fore.WHITE)
            print()
        
        # Valor do elemento
        value = safe_get(element_data, 'value')
        if value and value != 'N/A':
            print_colored("VALOR:", Fore.YELLOW)
            print_colored(f"  {value}", Fore.WHITE)
            print()
        
        # Padrões suportados
        patterns = element_data.get('supported_patterns', {}) if isinstance(element_data, dict) else {}
        if isinstance(patterns, dict):
            supported_patterns = []
            for name, info in patterns.items():
                if info and info != False and info != 'False':
                    if isinstance(info, dict) and info.get('supported'):
                        extra_info = []
                        if info.get('value') is not None:
                            extra_info.append(f"valor='{info['value']}'")
                        if info.get('is_read_only') is not None:
                            extra_info.append(f"readonly={info['is_read_only']}")
                        
                        extra_str = f" ({', '.join(extra_info)})" if extra_info else ""
                        supported_patterns.append(f"{name}{extra_str}")
                    else:
                        supported_patterns.append(name)
            
            if supported_patterns:
                print_colored("PADRÕES SUPORTADOS:", Fore.YELLOW)
                for pattern in supported_patterns:
                    print_colored(f"  {pattern}", Fore.WHITE)
                print()
        
        # Informações do processo
        process_info = element_data.get('process_info', {}) if isinstance(element_data, dict) else {}
        if isinstance(process_info, dict) and process_info and not process_info.get('error'):
            print_colored("PROCESSO:", Fore.YELLOW)
            print_colored(f"  Nome: {safe_get(process_info, 'name')}", Fore.WHITE)
            print_colored(f"  Executável: {safe_get(process_info, 'exe')}", Fore.WHITE)
            print()
        
        # Seletores XML
        selectors = element_data.get('xml_selectors', []) if isinstance(element_data, dict) else []
        if isinstance(selectors, list) and selectors:
            print_colored("SELETORES XML:", Fore.YELLOW)
            for i, selector in enumerate(selectors[:3], 1):  # Mostra apenas os 3 primeiros
                print_colored(f"  Seletor {i}:", Fore.CYAN)
                if isinstance(selector, str):
                    print_colored(selector, Fore.WHITE)
                else:
                    print_colored(str(selector), Fore.WHITE)
                print()
        elif isinstance(selectors, str):
            print_colored("SELETORES XML:", Fore.YELLOW)
            print_colored(selectors, Fore.WHITE)
            print()
    
    def show_saved_element_details(self, element_folder):
        """Exibe detalhes de um elemento salvo"""
        try:
            file_path = os.path.join("captured_elements", element_folder, "element_data.json")
            
            if not os.path.exists(file_path):
                print_error("Arquivo de dados não encontrado")
                return
            
            import json
            with open(file_path, 'r', encoding='utf-8') as f:
                element_data = json.load(f)
            
            self.show_element_details(element_data)
            
        except Exception as e:
            print_error(f"Erro ao carregar elemento: {str(e)}")
    
    def open_elements_folder(self):
        """Abre pasta de elementos capturados"""
        import subprocess
        import platform
        
        folder_path = os.path.abspath("captured_elements")
        
        if not os.path.exists(folder_path):
            os.makedirs(folder_path)
        
        try:
            if platform.system() == "Windows":
                os.startfile(folder_path)
            elif platform.system() == "Darwin":  # macOS
                subprocess.run(["open", folder_path])
            else:  # Linux
                subprocess.run(["xdg-open", folder_path])
            
            print_success(f"Pasta aberta: {folder_path}")
            
        except Exception as e:
            print_error(f"Erro ao abrir pasta: {str(e)}")
            print_info(f"Caminho da pasta: {folder_path}")
        
        wait_for_keypress()
    
    def show_help(self):
        """Exibe ajuda"""
        print_header("AJUDA - UI INSPECTOR")
        
        print_colored("SOBRE:", Fore.YELLOW)
        print_colored("  O UI Inspector é uma ferramenta para capturar informações", Fore.WHITE)
        print_colored("  detalhadas de elementos de interface em programas Windows.", Fore.WHITE)
        print()
        
        print_colored("COMO USAR:", Fore.YELLOW)
        print_colored("  1. Escolha 'Capturar Elemento' no menu principal", Fore.WHITE)
        print_colored("  2. Digite um nome para identificar o elemento", Fore.WHITE)
        print_colored("  3. CTRL + Click no elemento desejado para capturar", Fore.WHITE)
        print()
        
        print_colored("LISTAGEM DE ELEMENTOS:", Fore.YELLOW)
        print_colored("  • Lista todos os elementos com preview básico", Fore.WHITE)
        print_colored("  • Digite número para ver detalhes COMPLETOS de um elemento", Fore.WHITE)
        print_colored("  • Digite 'todos' para ver TODOS os elementos em detalhes", Fore.WHITE)
        print()
        
        print_colored("INFORMAÇÕES CAPTURADAS:", Fore.YELLOW)
        print_colored("  • AutomationId, Name, ClassName", Fore.WHITE)
        print_colored("  • ControlType, LocalizedControlType", Fore.WHITE)
        print_colored("  • FrameworkId, FrameworkType", Fore.WHITE)
        print_colored("  • ProcessId, informações da janela", Fore.WHITE)
        print_colored("  • Padrões de automação suportados", Fore.WHITE)
        print_colored("  • Seletores XML robustos para automação", Fore.WHITE)
        print_colored("  • Debug avançado de propriedades da janela", Fore.WHITE)
        print()
        
        print_colored("CONTROLES:", Fore.YELLOW)
        print_colored("  CTRL + Click - Capturar elemento", Fore.GREEN)
        print_colored("  ESC         - Cancelar captura", Fore.GREEN)
        print()
        
        print_colored("ARQUIVOS E VISUALIZAÇÃO:", Fore.YELLOW)
        print_colored("  Os elementos são salvos em 'captured_elements/'", Fore.WHITE)
        print_colored("  Cada elemento fica em uma pasta separada", Fore.WHITE)
        print_colored("  Dados salvos em formato JSON", Fore.WHITE)
        print_colored("  Detalhes completos exibidos diretamente na listagem", Fore.WHITE)
        print()
        
        wait_for_keypress()
    
    def run(self):
        """Loop principal da aplicação"""
        try:
            self.show_banner()
            
            while self.running:
                self.show_main_menu()
                choice = self.get_user_choice()
                
                if choice == "1":
                    self.capture_element_workflow()
                elif choice == "2":
                    self.list_captured_elements()
                elif choice == "3":
                    self.open_elements_folder()
                elif choice == "4":
                    self.show_help()
                elif choice == "5":
                    print_info("Encerrando UI Inspector...")
                    self.running = False
                else:
                    print_error("Opção inválida. Tente novamente.")
                    time.sleep(1)
        
        except KeyboardInterrupt:
            print()
            print_info("Encerrando UI Inspector...")
        except Exception as e:
            print_error(f"Erro inesperado: {str(e)}")
        finally:
            print_colored("Obrigado por usar o UI Inspector!", Fore.GREEN)

def main():
    """Função principal"""
    # Verifica dependências
    try:
        import uiautomation
        import win32gui
        import win32api
        import win32con
        import psutil
        import colorama
    except ImportError as e:
        print(f"Erro: Dependência não encontrada - {e}")
        print("Execute: pip install -r requirements.txt")
        sys.exit(1)
    
    # Verifica se está rodando no Windows
    if os.name != 'nt':
        print("Erro: Este programa funciona apenas no Windows")
        sys.exit(1)
    
    # Inicia aplicação
    app = UIInspectorApp()
    app.run()

if __name__ == "__main__":
    main()